{"mappings":"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","sources":["packages/react-aria-components/src/TreeDropTargetDelegate.ts"],"sourcesContent":["import {Direction, DropTarget, DropTargetDelegate, ItemDropTarget, Key, Node, RootDropTarget} from '@react-types/shared';\n\ninterface TreeCollection<T> extends Iterable<Node<T>> {\n  getItem(key: Key): Node<T> | null,\n  getChildren?(key: Key): Iterable<Node<T>>,\n  getKeyAfter(key: Key): Key | null,\n  getKeyBefore(key: Key): Key | null\n}\n\ninterface TreeState<T> {\n  collection: TreeCollection<T>,\n  expandedKeys: Set<Key>\n}\n\ninterface PointerTracking {\n  lastY: number,\n  lastX: number,\n  yDirection: 'up' | 'down' | null,\n  xDirection: 'left' | 'right' | null,\n  boundaryContext: {\n    parentKey: Key,\n    lastSwitchY: number,\n    lastSwitchX: number,\n    preferredTargetIndex?: number\n  } | null\n}\n\nconst X_SWITCH_THRESHOLD = 10;\nconst Y_SWITCH_THRESHOLD = 5;\nexport class TreeDropTargetDelegate<T> {\n  private delegate: DropTargetDelegate | null = null;\n  private state: TreeState<T> | null = null;\n  private direction: Direction = 'ltr';\n  private pointerTracking: PointerTracking = {\n    lastY: 0,\n    lastX: 0,\n    yDirection: null,\n    xDirection: null,\n    boundaryContext: null\n  };\n\n  setup(delegate: DropTargetDelegate, state: TreeState<T>, direction: Direction): void {\n    this.delegate = delegate;\n    this.state = state;\n    this.direction = direction;\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget | null {\n    let baseTarget = this.delegate!.getDropTargetFromPoint(x, y, isValidDropTarget);\n    if (!baseTarget || baseTarget.type === 'root') {\n      return baseTarget;\n    }\n\n    return this.resolveDropTarget(baseTarget, x, y, isValidDropTarget);\n  }\n\n  private resolveDropTarget(\n    target: ItemDropTarget,\n    x: number,\n    y: number,\n    isValidDropTarget: (target: DropTarget) => boolean\n  ): RootDropTarget | ItemDropTarget | null {\n    let tracking = this.pointerTracking;\n\n    // Calculate movement directions\n    let deltaY = y - tracking.lastY;\n    let deltaX = x - tracking.lastX;\n    let currentYMovement: 'up' | 'down' | null = tracking.yDirection;\n    let currentXMovement: 'left' | 'right' | null = tracking.xDirection;\n\n    if (Math.abs(deltaY) > Y_SWITCH_THRESHOLD) {\n      currentYMovement = deltaY > 0 ? 'down' : 'up';\n      tracking.yDirection = currentYMovement;\n      tracking.lastY = y;\n    }\n\n    if (Math.abs(deltaX) > X_SWITCH_THRESHOLD) {\n      currentXMovement = deltaX > 0 ? 'right' : 'left';\n      tracking.xDirection = currentXMovement;\n      tracking.lastX = x;\n    }\n\n    // Normalize to 'after'\n    if (target.dropPosition === 'before') {\n      let keyBefore = this.state!.collection.getKeyBefore(target.key);\n      if (keyBefore != null) {\n        target = {\n          type: 'item',\n          key: keyBefore,\n          dropPosition: 'after'\n        } as const;\n      }\n    }\n\n    let potentialTargets = this.getPotentialTargets(target, isValidDropTarget);\n\n    if (potentialTargets.length === 0) {\n      return {type: 'root'};\n    }\n\n    let resolvedItemTarget: ItemDropTarget;\n    if (potentialTargets.length > 1) {\n      resolvedItemTarget = this.selectTarget(potentialTargets, target, x, y, currentYMovement, currentXMovement);\n    } else {\n      resolvedItemTarget = potentialTargets[0];\n      // Reset boundary context since we're not in a boundary case\n      tracking.boundaryContext = null;\n    }\n\n    return resolvedItemTarget;\n  }\n\n  // Returns potential targets for an ambiguous drop position (e.g. after the last child of a parent, or after the parent itself)\n  // Ordered by level, from innermost to outermost.\n  private getPotentialTargets(originalTarget: ItemDropTarget, isValidDropTarget: (target: DropTarget) => boolean): ItemDropTarget[] {\n    if (originalTarget.dropPosition === 'on') {\n      return [originalTarget];\n    }\n\n    let target = originalTarget;\n    let collection = this.state!.collection;\n\n    let currentItem = collection.getItem(target.key);\n    while (currentItem && currentItem?.type !== 'item' && currentItem.nextKey != null) {\n      target.key = currentItem.nextKey;\n      currentItem = collection.getItem(currentItem.nextKey);\n    }\n\n    let potentialTargets = [target];\n\n    // If target has children and is expanded, use \"before first child\"\n    if (currentItem && currentItem.hasChildNodes && this.state!.expandedKeys.has(currentItem.key) && collection.getChildren && target.dropPosition === 'after') {\n      let firstChildItemNode: Node<T> | null = null;\n      for (let child of collection.getChildren(currentItem.key)) {\n        if (child.type === 'item') {\n          firstChildItemNode = child;\n          break;\n        }\n      }\n\n      if (firstChildItemNode) {\n        const beforeFirstChildTarget = {\n          type: 'item',\n          key: firstChildItemNode.key,\n          dropPosition: 'before'\n        } as const;\n\n        if (isValidDropTarget(beforeFirstChildTarget)) {\n          return [beforeFirstChildTarget];\n        } else {\n          return [];\n        }\n      }\n    }\n\n    if (currentItem?.nextKey != null) {\n      return [originalTarget];\n    }\n\n    // Walk up the parent chain to find ancestors that are the last child at their level\n    let parentKey = currentItem?.parentKey;\n    let ancestorTargets: ItemDropTarget[] = [];\n\n    while (parentKey) {\n      let parentItem = collection.getItem(parentKey);\n      let nextItem = parentItem?.nextKey ? collection.getItem(parentItem.nextKey) : null;\n      let isLastChildAtLevel = !nextItem || nextItem.parentKey !== parentKey;\n\n      if (isLastChildAtLevel) {\n        let afterParentTarget = {\n          type: 'item',\n          key: parentKey,\n          dropPosition: 'after'\n        } as const;\n\n        if (isValidDropTarget(afterParentTarget)) {\n          ancestorTargets.push(afterParentTarget);\n        }\n        if (nextItem) {\n          break;\n        }\n      }\n\n      parentKey = parentItem?.parentKey;\n    }\n\n    if (ancestorTargets.length > 0) {\n      potentialTargets.push(...ancestorTargets);\n    }\n\n    // Handle converting \"after\" to \"before next\" for non-ambiguous cases\n    if (potentialTargets.length === 1) {\n      let nextKey = collection.getKeyAfter(target.key);\n      let nextNode = nextKey ? collection.getItem(nextKey) : null;\n      if (nextKey != null && nextNode && currentItem && nextNode.level != null && currentItem.level != null && nextNode.level > currentItem.level) {\n        let beforeTarget = {\n          type: 'item',\n          key: nextKey,\n          dropPosition: 'before'\n        } as const;\n        if (isValidDropTarget(beforeTarget)) {\n          return [beforeTarget];\n        }\n      }\n    }\n\n    return potentialTargets.filter(isValidDropTarget);\n  }\n\n  private selectTarget(\n    potentialTargets: ItemDropTarget[],\n    originalTarget: ItemDropTarget,\n    x: number,\n    y: number,\n    currentYMovement: 'up' | 'down' | null,\n    currentXMovement: 'left' | 'right' | null\n  ): ItemDropTarget {\n    if (potentialTargets.length < 2) {\n      return potentialTargets[0];\n    }\n\n    let tracking = this.pointerTracking;\n    let currentItem = this.state!.collection.getItem(originalTarget.key);\n    let parentKey = currentItem?.parentKey;\n\n    if (!parentKey) {\n      return potentialTargets[0];\n    }\n\n    // More than 1 potential target - use Y for initial target, then X for switching levels\n    // Initialize boundary context if needed\n    if (!tracking.boundaryContext || tracking.boundaryContext.parentKey !== parentKey) {\n      // If entering from below, start with outer-most\n      let initialTargetIndex = tracking.yDirection === 'up' ? potentialTargets.length - 1 : 0;\n      tracking.boundaryContext = {\n        parentKey,\n        preferredTargetIndex: initialTargetIndex,\n        lastSwitchY: y,\n        lastSwitchX: x\n      };\n    }\n\n    let boundaryContext = tracking.boundaryContext;\n    let distanceFromLastXSwitch = Math.abs(x - boundaryContext.lastSwitchX);\n    let distanceFromLastYSwitch = Math.abs(y - boundaryContext.lastSwitchY);\n\n    // Switch between targets based on Y movement\n    if (distanceFromLastYSwitch > Y_SWITCH_THRESHOLD && currentYMovement) {\n      let currentIndex = boundaryContext.preferredTargetIndex || 0;\n\n      if (currentYMovement === 'down' && currentIndex === 0) {\n        // Moving down from inner-most, switch to outer-most\n        boundaryContext.preferredTargetIndex = potentialTargets.length - 1;\n      } else if (currentYMovement === 'up' && currentIndex === potentialTargets.length - 1) {\n        // Moving up from outer-most, switch to inner-most\n        boundaryContext.preferredTargetIndex = 0;\n      }\n\n      // Reset x tracking so that moving diagonally doesn't cause flickering.\n      tracking.xDirection = null;\n    }\n\n    // X movement controls level selection\n    if (distanceFromLastXSwitch > X_SWITCH_THRESHOLD && currentXMovement) {\n      let currentTargetIndex = boundaryContext.preferredTargetIndex || 0;\n\n      if (currentXMovement === 'left') {\n        if (this.direction === 'ltr') {\n          // LTR: left = move to higher level in tree (increase index)\n          if (currentTargetIndex < potentialTargets.length - 1) {\n            boundaryContext.preferredTargetIndex = currentTargetIndex + 1;\n            boundaryContext.lastSwitchX = x;\n          }\n        } else {\n          // RTL: left = move to lower level in tree (decrease index)\n          if (currentTargetIndex > 0) {\n            boundaryContext.preferredTargetIndex = currentTargetIndex - 1;\n            boundaryContext.lastSwitchX = x;\n          }\n        }\n      } else if (currentXMovement === 'right') {\n        if (this.direction === 'ltr') {\n          // LTR: right = move to lower level in tree (decrease index)\n          if (currentTargetIndex > 0) {\n            boundaryContext.preferredTargetIndex = currentTargetIndex - 1;\n            boundaryContext.lastSwitchX = x;\n          }\n        } else {\n          // RTL: right = move to higher level in tree (increase index)\n          if (currentTargetIndex < potentialTargets.length - 1) {\n            boundaryContext.preferredTargetIndex = currentTargetIndex + 1;\n            boundaryContext.lastSwitchX = x;\n          }\n        }\n      }\n\n      // Reset y tracking so that moving diagonally doesn't cause flickering.\n      tracking.yDirection = null;\n    }\n\n    let targetIndex = Math.max(0, Math.min(boundaryContext.preferredTargetIndex || 0, potentialTargets.length - 1));\n    return potentialTargets[targetIndex];\n  }\n}\n"],"names":[],"version":3,"file":"TreeDropTargetDelegate.module.js.map"}