{"mappings":"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","sources":["packages/@react-aria/autocomplete/src/useAutocomplete.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, BaseEvent, DOMProps, RefObject} from '@react-types/shared';\nimport {AriaTextFieldProps} from '@react-aria/textfield';\nimport {AutocompleteProps, AutocompleteState} from '@react-stately/autocomplete';\nimport {CLEAR_FOCUS_EVENT, FOCUS_EVENT, getActiveElement, getOwnerDocument, isCtrlKeyPressed, mergeProps, mergeRefs, useEffectEvent, useId, useLabels, useObjectRef} from '@react-aria/utils';\nimport {dispatchVirtualBlur, dispatchVirtualFocus, moveVirtualFocus} from '@react-aria/focus';\nimport {getInteractionModality} from '@react-aria/interactions';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {FocusEvent as ReactFocusEvent, KeyboardEvent as ReactKeyboardEvent, useCallback, useEffect, useMemo, useRef} from 'react';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface CollectionOptions extends DOMProps, AriaLabelingProps {\n  /** Whether the collection items should use virtual focus instead of being focused directly. */\n  shouldUseVirtualFocus: boolean,\n  /** Whether typeahead is disabled. */\n  disallowTypeAhead: boolean\n}\nexport interface AriaAutocompleteProps extends AutocompleteProps {\n  /**\n   * An optional filter function used to determine if a option should be included in the autocomplete list.\n   * Include this if the items you are providing to your wrapped collection aren't filtered by default.\n   */\n  filter?: (textValue: string, inputValue: string) => boolean,\n\n  /**\n   * Whether or not to focus the first item in the collection after a filter is performed.\n   * @default false\n   */\n  disableAutoFocusFirst?: boolean\n}\n\nexport interface AriaAutocompleteOptions extends Omit<AriaAutocompleteProps, 'children'> {\n  /** The ref for the wrapped collection element. */\n  inputRef: RefObject<HTMLInputElement | null>,\n  /** The ref for the wrapped collection element. */\n  collectionRef: RefObject<HTMLElement | null>\n}\n\nexport interface AutocompleteAria {\n  /** Props for the autocomplete textfield/searchfield element. These should be passed to the textfield/searchfield aria hooks respectively. */\n  textFieldProps: AriaTextFieldProps,\n  /** Props for the collection, to be passed to collection's respective aria hook (e.g. useMenu). */\n  collectionProps: CollectionOptions,\n  /** Ref to attach to the wrapped collection. */\n  collectionRef: RefObject<HTMLElement | null>,\n  /** A filter function that returns if the provided collection node should be filtered out of the collection. */\n  filter?: (nodeTextValue: string) => boolean\n}\n\n/**\n * Provides the behavior and accessibility implementation for an autocomplete component.\n * An autocomplete combines a text input with a collection, allowing users to filter the collection's contents match a query.\n * @param props - Props for the autocomplete.\n * @param state - State for the autocomplete, as returned by `useAutocompleteState`.\n */\nexport function useAutocomplete(props: AriaAutocompleteOptions, state: AutocompleteState): AutocompleteAria {\n  let {\n    inputRef,\n    collectionRef,\n    filter,\n    disableAutoFocusFirst = false\n  } = props;\n\n  let collectionId = useId();\n  let timeout = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  let delayNextActiveDescendant = useRef(false);\n  let queuedActiveDescendant = useRef<string | null>(null);\n  let lastCollectionNode = useRef<HTMLElement>(null);\n\n  // For mobile screen readers, we don't want virtual focus, instead opting to disable FocusScope's restoreFocus and manually\n  // moving focus back to the subtriggers\n  let shouldUseVirtualFocus = getInteractionModality() !== 'virtual';\n\n  useEffect(() => {\n    return () => clearTimeout(timeout.current);\n  }, []);\n\n  let updateActiveDescendant = useEffectEvent((e: Event) => {\n    // Ensure input is focused if the user clicks on the collection directly.\n    if (!e.isTrusted && shouldUseVirtualFocus && inputRef.current && getActiveElement(getOwnerDocument(inputRef.current)) !== inputRef.current) {\n      inputRef.current.focus();\n    }\n\n    let target = e.target as Element | null;\n    if (e.isTrusted || !target || queuedActiveDescendant.current === target.id) {\n      return;\n    }\n\n    clearTimeout(timeout.current);\n    if (target !== collectionRef.current) {\n      if (delayNextActiveDescendant.current) {\n        queuedActiveDescendant.current = target.id;\n        timeout.current = setTimeout(() => {\n          state.setFocusedNodeId(target.id);\n        }, 500);\n      } else {\n        queuedActiveDescendant.current = target.id;\n        state.setFocusedNodeId(target.id);\n      }\n    } else {\n      queuedActiveDescendant.current = null;\n      state.setFocusedNodeId(null);\n    }\n\n    delayNextActiveDescendant.current = false;\n  });\n\n  let callbackRef = useCallback((collectionNode) => {\n    if (collectionNode != null) {\n      // When typing forward, we want to delay the setting of active descendant to not interrupt the native screen reader announcement\n      // of the letter you just typed. If we recieve another focus event then we clear the queued update\n      // We track lastCollectionNode to do proper cleanup since callbackRefs just pass null when unmounting. This also handles\n      // React 19's extra call of the callback ref in strict mode\n      lastCollectionNode.current?.removeEventListener('focusin', updateActiveDescendant);\n      lastCollectionNode.current = collectionNode;\n      collectionNode.addEventListener('focusin', updateActiveDescendant);\n    } else {\n      lastCollectionNode.current?.removeEventListener('focusin', updateActiveDescendant);\n    }\n  }, [updateActiveDescendant]);\n\n  // Make sure to memo so that React doesn't keep registering a new event listeners on every rerender of the wrapped collection\n  let mergedCollectionRef = useObjectRef(useMemo(() => mergeRefs(collectionRef, callbackRef), [collectionRef, callbackRef]));\n\n  let focusFirstItem = useEffectEvent(() => {\n    delayNextActiveDescendant.current = true;\n    collectionRef.current?.dispatchEvent(\n      new CustomEvent(FOCUS_EVENT, {\n        cancelable: true,\n        bubbles: true,\n        detail: {\n          focusStrategy: 'first'\n        }\n      })\n    );\n  });\n\n  let clearVirtualFocus = useEffectEvent((clearFocusKey?: boolean) => {\n    moveVirtualFocus(getActiveElement());\n    queuedActiveDescendant.current = null;\n    state.setFocusedNodeId(null);\n    let clearFocusEvent = new CustomEvent(CLEAR_FOCUS_EVENT, {\n      cancelable: true,\n      bubbles: true,\n      detail: {\n        clearFocusKey\n      }\n    });\n    clearTimeout(timeout.current);\n    delayNextActiveDescendant.current = false;\n    collectionRef.current?.dispatchEvent(clearFocusEvent);\n  });\n\n  // TODO: update to see if we can tell what kind of event (paste vs backspace vs typing) is happening instead\n  let onChange = (value: string) => {\n    // Tell wrapped collection to focus the first element in the list when typing forward and to clear focused key when deleting text\n    // for screen reader announcements\n    if (state.inputValue !== value && state.inputValue.length <= value.length && !disableAutoFocusFirst) {\n      focusFirstItem();\n    } else {\n      // Fully clear focused key when backspacing since the list may change and thus we'd want to start fresh again\n      clearVirtualFocus(true);\n    }\n\n    state.setInputValue(value);\n  };\n\n  let keyDownTarget = useRef<Element | null>(null);\n  // For textfield specific keydown operations\n  let onKeyDown = (e: BaseEvent<ReactKeyboardEvent<any>>) => {\n    keyDownTarget.current = e.target as Element;\n    if (e.nativeEvent.isComposing) {\n      return;\n    }\n\n    let focusedNodeId = queuedActiveDescendant.current;\n    switch (e.key) {\n      case 'a':\n        if (isCtrlKeyPressed(e)) {\n          return;\n        }\n        break;\n      case 'Escape':\n        // Early return for Escape here so it doesn't leak the Escape event from the simulated collection event below and\n        // close the dialog prematurely. Ideally that should be up to the discretion of the input element hence the check\n        // for isPropagationStopped\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        break;\n      case ' ':\n        // Space shouldn't trigger onAction so early return.\n        return;\n      case 'Tab':\n        // Don't propogate Tab down to the collection, otherwise we will try to focus the collection via useSelectableCollection's Tab handler (aka shift tab logic)\n        // We want FocusScope to handle Tab if one exists (aka sub dialog), so special casepropogate\n        if ('continuePropagation' in e) {\n          e.continuePropagation();\n        }\n        return;\n      case 'Home':\n      case 'End':\n      case 'PageDown':\n      case 'PageUp':\n      case 'ArrowUp':\n      case 'ArrowDown': {\n        if ((e.key === 'Home' || e.key === 'End') && focusedNodeId == null && e.shiftKey) {\n          return;\n        }\n\n        // Prevent these keys from moving the text cursor in the input\n        e.preventDefault();\n        // Move virtual focus into the wrapped collection\n        let focusCollection = new CustomEvent(FOCUS_EVENT, {\n          cancelable: true,\n          bubbles: true\n        });\n\n        collectionRef.current?.dispatchEvent(focusCollection);\n        break;\n      }\n    }\n\n    // Emulate the keyboard events that happen in the input field in the wrapped collection. This is for triggering things like onAction via Enter\n    // or moving focus from one item to another. Stop propagation on the input event if it isn't already stopped so it doesn't leak out. For events\n    // like ESC, the dispatched event below will bubble out of the collection and be stopped if handled by useSelectableCollection, otherwise will bubble\n    // as expected\n    if (!e.isPropagationStopped()) {\n      e.stopPropagation();\n    }\n\n    let shouldPerformDefaultAction = true;\n    if (focusedNodeId == null) {\n      shouldPerformDefaultAction = collectionRef.current?.dispatchEvent(\n        new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n      ) || false;\n    } else {\n      let item = document.getElementById(focusedNodeId);\n      shouldPerformDefaultAction = item?.dispatchEvent(\n        new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n      ) || false;\n    }\n\n    if (shouldPerformDefaultAction) {\n      switch (e.key) {\n        case 'ArrowLeft':\n        case 'ArrowRight': {\n          // Clear the activedescendant so NVDA announcements aren't interrupted but retain the focused key in the collection so the\n          // user's keyboard navigation restarts from where they left off\n          clearVirtualFocus();\n          break;\n        }\n      }\n    }\n  };\n\n  let onKeyUpCapture = useEffectEvent((e) => {\n    // Dispatch simulated key up events for things like triggering links in listbox\n    // Make sure to stop the propagation of the input keyup event so that the simulated keyup/down pair\n    // is detected by usePress instead of the original keyup originating from the input\n    if (e.target === keyDownTarget.current) {\n      e.stopImmediatePropagation();\n      let focusedNodeId = queuedActiveDescendant.current;\n      if (focusedNodeId == null) {\n        collectionRef.current?.dispatchEvent(\n          new KeyboardEvent(e.type, e)\n        );\n      } else {\n        let item = document.getElementById(focusedNodeId);\n        item?.dispatchEvent(\n          new KeyboardEvent(e.type, e)\n        );\n      }\n    }\n  });\n\n  useEffect(() => {\n    document.addEventListener('keyup', onKeyUpCapture, true);\n    return () => {\n      document.removeEventListener('keyup', onKeyUpCapture, true);\n    };\n  }, [onKeyUpCapture]);\n\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/autocomplete');\n  let collectionProps = useLabels({\n    id: collectionId,\n    'aria-label': stringFormatter.format('collectionLabel')\n  });\n\n  let filterFn = useCallback((nodeTextValue: string) => {\n    if (filter) {\n      return filter(nodeTextValue, state.inputValue);\n    }\n\n    return true;\n  }, [state.inputValue, filter]);\n\n  // Be sure to clear/restore the virtual + collection focus when blurring/refocusing the field so we only show the\n  // focus ring on the virtually focused collection when are actually interacting with the Autocomplete\n  let onBlur = (e: ReactFocusEvent) => {\n    if (!e.isTrusted) {\n      return;\n    }\n\n    let lastFocusedNode = queuedActiveDescendant.current ? document.getElementById(queuedActiveDescendant.current) : null;\n    if (lastFocusedNode) {\n      dispatchVirtualBlur(lastFocusedNode, e.relatedTarget);\n    }\n  };\n\n  let onFocus = (e: ReactFocusEvent) => {\n    if (!e.isTrusted) {\n      return;\n    }\n\n    let curFocusedNode = queuedActiveDescendant.current ? document.getElementById(queuedActiveDescendant.current) : null;\n    if (curFocusedNode) {\n      let target = e.target;\n      queueMicrotask(() => {\n        dispatchVirtualBlur(target, curFocusedNode);\n        dispatchVirtualFocus(curFocusedNode, target);\n      });\n    }\n  };\n\n  return {\n    textFieldProps: {\n      value: state.inputValue,\n      onChange,\n      onKeyDown,\n      autoComplete: 'off',\n      'aria-haspopup': 'listbox',\n      'aria-controls': collectionId,\n      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)\n      'aria-autocomplete': 'list',\n      'aria-activedescendant': state.focusedNodeId ?? undefined,\n      // This disable's iOS's autocorrect suggestions, since the autocomplete provides its own suggestions.\n      autoCorrect: 'off',\n      // This disable's the macOS Safari spell check auto corrections.\n      spellCheck: 'false',\n      enterKeyHint: 'go',\n      onBlur,\n      onFocus\n    },\n    collectionProps: mergeProps(collectionProps, {\n      shouldUseVirtualFocus,\n      disallowTypeAhead: true\n    }),\n    collectionRef: mergedCollectionRef,\n    filter: filter != null ? filterFn : undefined\n  };\n}\n"],"names":[],"version":3,"file":"useAutocomplete.main.js.map"}