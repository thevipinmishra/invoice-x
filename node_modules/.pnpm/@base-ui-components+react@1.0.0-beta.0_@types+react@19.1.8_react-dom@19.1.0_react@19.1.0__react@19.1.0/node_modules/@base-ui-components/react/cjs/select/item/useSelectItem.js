"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSelectItem = useSelectItem;
var React = _interopRequireWildcard(require("react"));
var _useButton = require("../../use-button");
var _mergeProps = require("../../merge-props");
var _useTimeout = require("../../utils/useTimeout");
var _useEventCallback = require("../../utils/useEventCallback");
var _useForkRef = require("../../utils/useForkRef");
var _utils = require("../../utils");
var _highlighted = require("../../utils/highlighted");
var _isMouseWithinBounds = require("../../utils/isMouseWithinBounds");
var _useAnimationFrame = require("../../utils/useAnimationFrame");
function useSelectItem(params) {
  const {
    open,
    disabled = false,
    highlighted,
    selected,
    ref: externalRef,
    setOpen,
    typingRef,
    handleSelect,
    selectionRef,
    indexRef,
    setActiveIndex,
    selectedIndexRef,
    popupRef,
    keyboardActiveRef,
    events,
    elementProps,
    rootProps
  } = params;
  const ref = React.useRef(null);
  const lastKeyRef = React.useRef(null);
  const pointerTypeRef = React.useRef('mouse');
  const didPointerDownRef = React.useRef(false);
  const prevPopupHeightRef = React.useRef(0);
  const allowFocusSyncRef = React.useRef(true);
  const cursorMovementTimeout = (0, _useTimeout.useTimeout)();
  const mergedRef = (0, _useForkRef.useForkRef)(externalRef, ref);
  const {
    getButtonProps,
    buttonRef
  } = (0, _useButton.useButton)({
    disabled,
    focusableWhenDisabled: true,
    buttonRef: mergedRef
  });
  const commitSelection = (0, _useEventCallback.useEventCallback)(event => {
    handleSelect(event);
    setOpen(false, event, 'item-press');
  });
  const handlePopupLeave = (0, _useEventCallback.useEventCallback)(() => {
    if (cursorMovementTimeout.isStarted()) {
      cursorMovementTimeout.clear();
      (0, _highlighted.removeHighlight)(ref);
    }
  });
  React.useEffect(() => {
    return handlePopupLeave;
  }, [handlePopupLeave]);
  (0, _utils.useModernLayoutEffect)(() => {
    if (!open) {
      return;
    }
    if (highlighted) {
      (0, _highlighted.addHighlight)(ref);
    } else {
      (0, _highlighted.removeHighlight)(ref);
    }
  }, [open, highlighted]);
  React.useEffect(() => {
    function handleItemHover(item) {
      if (ref.current && item !== ref.current) {
        (0, _highlighted.removeHighlight)(ref);
      }
    }
    events.on('itemhover', handleItemHover);
    return () => {
      events.off('itemhover', handleItemHover);
    };
  }, [events, setActiveIndex, indexRef]);
  const props = (0, _mergeProps.mergeProps)(rootProps, {
    'aria-disabled': disabled || undefined,
    tabIndex: highlighted ? 0 : -1,
    onFocus() {
      if (allowFocusSyncRef.current && keyboardActiveRef.current && cursorMovementTimeout.isStarted() === false) {
        setActiveIndex(indexRef.current);
      }
    },
    onMouseEnter() {
      if (!keyboardActiveRef.current && selectedIndexRef.current === null) {
        (0, _highlighted.addHighlight)(ref);
        events.emit('itemhover', ref.current);
      }
    },
    onMouseMove() {
      if (keyboardActiveRef.current) {
        setActiveIndex(indexRef.current);
      } else {
        (0, _highlighted.addHighlight)(ref);
        events.emit('itemhover', ref.current);
      }
      if (popupRef.current) {
        prevPopupHeightRef.current = popupRef.current.offsetHeight;
      }
      events.off('popupleave', handlePopupLeave);
      events.on('popupleave', handlePopupLeave);
      // When this fires, the cursor has stopped moving.
      cursorMovementTimeout.start(50, () => {
        setActiveIndex(indexRef.current);
      });
    },
    onMouseLeave(event) {
      const popup = popupRef.current;
      if (!popup || !open || keyboardActiveRef.current) {
        return;
      }
      if ((0, _isMouseWithinBounds.isMouseWithinBounds)(event)) {
        return;
      }
      (0, _highlighted.removeHighlight)(ref);
      events.off('popupleave', handlePopupLeave);
      const wasCursorStationary = cursorMovementTimeout.isStarted() === false;
      if (!wasCursorStationary) {
        cursorMovementTimeout.clear();
      }

      // With `alignItemWithTrigger=true`, avoid re-rendering the root due to `onMouseLeave`
      // firing and causing a performance issue when expanding the popup.
      if (popup.offsetHeight === prevPopupHeightRef.current) {
        // Prevent `onFocus` from causing the highlight to be stuck when quickly moving
        // the mouse out of the popup.
        allowFocusSyncRef.current = false;
        if (keyboardActiveRef.current || wasCursorStationary) {
          setActiveIndex(null);
        }
        _useAnimationFrame.AnimationFrame.request(() => {
          cursorMovementTimeout.clear();
          allowFocusSyncRef.current = true;
        });
      }
    },
    onTouchStart() {
      selectionRef.current = {
        allowSelectedMouseUp: false,
        allowUnselectedMouseUp: false,
        allowSelect: true
      };
    },
    onKeyDown(event) {
      selectionRef.current.allowSelect = true;
      lastKeyRef.current = event.key;
      setActiveIndex(indexRef.current);
    },
    onClick(event) {
      didPointerDownRef.current = false;

      // Prevent double commit on {Enter}
      if (event.type === 'keydown' && lastKeyRef.current === null) {
        return;
      }
      if (disabled || lastKeyRef.current === ' ' && typingRef.current || pointerTypeRef.current !== 'touch' && !(0, _highlighted.hasHighlight)(ref)) {
        return;
      }
      if (selectionRef.current.allowSelect) {
        lastKeyRef.current = null;
        commitSelection(event.nativeEvent);
      }
    },
    onPointerEnter(event) {
      pointerTypeRef.current = event.pointerType;
    },
    onPointerDown(event) {
      pointerTypeRef.current = event.pointerType;
      didPointerDownRef.current = true;
    },
    onMouseUp(event) {
      if (disabled) {
        return;
      }
      if (didPointerDownRef.current) {
        didPointerDownRef.current = false;
        return;
      }
      const disallowSelectedMouseUp = !selectionRef.current.allowSelectedMouseUp && selected;
      const disallowUnselectedMouseUp = !selectionRef.current.allowUnselectedMouseUp && !selected;
      if (disallowSelectedMouseUp || disallowUnselectedMouseUp || pointerTypeRef.current !== 'touch' && !(0, _highlighted.hasHighlight)(ref)) {
        return;
      }
      if (selectionRef.current.allowSelect || !selected) {
        commitSelection(event.nativeEvent);
      }
      selectionRef.current.allowSelect = true;
    }
  }, elementProps, getButtonProps);
  return {
    rootRef: buttonRef,
    props
  };
}