"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSelectTrigger = useSelectTrigger;
var React = _interopRequireWildcard(require("react"));
var _utils = require("@floating-ui/react/utils");
var _useButton = require("../../use-button/useButton");
var _mergeProps = require("../../merge-props");
var _useForkRef = require("../../utils/useForkRef");
var _useTimeout = require("../../utils/useTimeout");
var _SelectRootContext = require("../root/SelectRootContext");
var _owner = require("../../utils/owner");
var _FieldRootContext = require("../../field/root/FieldRootContext");
var _getPseudoElementBounds = require("../../utils/getPseudoElementBounds");
const BOUNDARY_OFFSET = 2;
function useSelectTrigger(parameters) {
  const {
    elementProps,
    disabled = false,
    rootRef: externalRef
  } = parameters;
  const {
    open,
    setOpen,
    setTriggerElement,
    selectionRef,
    value,
    fieldControlValidation,
    setTouchModality,
    positionerElement,
    readOnly,
    alignItemWithTriggerActiveRef,
    triggerProps,
    setTypeaheadReady
  } = (0, _SelectRootContext.useSelectRootContext)();
  const {
    labelId,
    setTouched,
    setFocused,
    validationMode
  } = (0, _FieldRootContext.useFieldRootContext)();
  const triggerRef = React.useRef(null);
  const timeout = (0, _useTimeout.useTimeout)();
  const mergedRef = (0, _useForkRef.useForkRef)(externalRef, triggerRef);
  const {
    getButtonProps,
    buttonRef
  } = (0, _useButton.useButton)({
    disabled,
    buttonRef: mergedRef
  });
  const handleRef = (0, _useForkRef.useForkRef)(buttonRef, setTriggerElement);
  const timeout1 = (0, _useTimeout.useTimeout)();
  const timeout2 = (0, _useTimeout.useTimeout)();
  React.useEffect(() => {
    if (open) {
      // mousedown -> mouseup on selected item should not select within 400ms.
      timeout1.start(400, () => {
        selectionRef.current.allowSelectedMouseUp = true;
      });
      // mousedown -> move to unselected item -> mouseup should not select within 200ms.
      timeout2.start(200, () => {
        selectionRef.current.allowUnselectedMouseUp = true;
      });
      return () => {
        timeout1.clear();
        timeout2.clear();
      };
    }
    selectionRef.current = {
      allowSelectedMouseUp: false,
      allowUnselectedMouseUp: false,
      allowSelect: true
    };
    timeout.clear();
    return undefined;
  }, [open, selectionRef, timeout, timeout1, timeout2]);
  const props = (0, _mergeProps.mergeProps)(triggerProps, {
    'aria-labelledby': labelId,
    'aria-readonly': readOnly || undefined,
    tabIndex: disabled ? -1 : 0,
    ref: handleRef,
    onFocus(event) {
      setTypeaheadReady(true);
      setFocused(true);
      // The popup element shouldn't obscure the focused trigger.
      if (open && alignItemWithTriggerActiveRef.current) {
        setOpen(false, event.nativeEvent, 'focus-out');
      }
    },
    onBlur() {
      setTouched(true);
      setFocused(false);
      if (validationMode === 'onBlur') {
        fieldControlValidation.commitValidation(value);
      }
    },
    onPointerMove({
      pointerType
    }) {
      setTouchModality(pointerType === 'touch');
    },
    onPointerDown({
      pointerType
    }) {
      setTouchModality(pointerType === 'touch');
    },
    onMouseDown(event) {
      if (open) {
        return;
      }
      const doc = (0, _owner.ownerDocument)(event.currentTarget);
      function handleMouseUp(mouseEvent) {
        if (!triggerRef.current) {
          return;
        }
        const mouseUpTarget = mouseEvent.target;

        // Early return if clicked on trigger element or its children
        if ((0, _utils.contains)(triggerRef.current, mouseUpTarget) || (0, _utils.contains)(positionerElement, mouseUpTarget) || mouseUpTarget === triggerRef.current) {
          return;
        }
        const bounds = (0, _getPseudoElementBounds.getPseudoElementBounds)(triggerRef.current);
        if (mouseEvent.clientX >= bounds.left - BOUNDARY_OFFSET && mouseEvent.clientX <= bounds.right + BOUNDARY_OFFSET && mouseEvent.clientY >= bounds.top - BOUNDARY_OFFSET && mouseEvent.clientY <= bounds.bottom + BOUNDARY_OFFSET) {
          return;
        }
        setOpen(false, mouseEvent, 'cancel-open');
      }

      // Firefox can fire this upon mousedown
      timeout.start(0, () => {
        doc.addEventListener('mouseup', handleMouseUp, {
          once: true
        });
      });
    }
  }, fieldControlValidation.getValidationProps, elementProps, getButtonProps);

  // ensure nested useButton does not overwrite the combobox role:
  // <Toolbar.Button render={<Select.Trigger />} />
  props.role = 'combobox';
  return {
    props,
    rootRef: handleRef
  };
}