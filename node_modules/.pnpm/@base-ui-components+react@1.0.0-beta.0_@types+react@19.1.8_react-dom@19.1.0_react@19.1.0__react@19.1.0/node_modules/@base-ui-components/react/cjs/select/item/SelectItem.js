"use strict";
'use client';

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SelectItem = void 0;
var React = _interopRequireWildcard(require("react"));
var _SelectRootContext = require("../root/SelectRootContext");
var _SelectIndexContext = require("../root/SelectIndexContext");
var _useCompositeListItem = require("../../composite/list/useCompositeListItem");
var _useForkRef = require("../../utils/useForkRef");
var _useSelectItem = require("./useSelectItem");
var _useModernLayoutEffect = require("../../utils/useModernLayoutEffect");
var _useLatestRef = require("../../utils/useLatestRef");
var _SelectItemContext = require("./SelectItemContext");
var _useRenderElement = require("../../utils/useRenderElement");
var _jsxRuntime = require("react/jsx-runtime");
const InnerSelectItem = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(function InnerSelectItem(componentProps, forwardedRef) {
  const {
    className,
    disabled = false,
    highlighted,
    selected,
    getRootItemProps,
    render,
    setOpen,
    typingRef,
    selectionRef,
    open,
    value,
    setValue,
    selectedIndexRef,
    indexRef,
    setActiveIndex,
    popupRef,
    keyboardActiveRef,
    events,
    textRef,
    ...elementProps
  } = componentProps;
  const state = React.useMemo(() => ({
    disabled,
    selected
  }), [disabled, selected]);
  const rootProps = getRootItemProps({
    active: highlighted,
    selected
  });
  // With our custom `focusItemOnHover` implementation, this interferes with the logic and can
  // cause the index state to be stuck when leaving the select popup.
  delete rootProps.onFocus;
  delete rootProps.id;
  const {
    props,
    rootRef
  } = (0, _useSelectItem.useSelectItem)({
    open,
    setOpen,
    disabled,
    highlighted,
    selected,
    ref: forwardedRef,
    typingRef,
    handleSelect: event => setValue(value, event),
    selectionRef,
    selectedIndexRef,
    indexRef,
    setActiveIndex,
    popupRef,
    keyboardActiveRef,
    events,
    rootProps,
    elementProps
  });
  const element = (0, _useRenderElement.useRenderElement)('div', componentProps, {
    ref: [rootRef, forwardedRef],
    state,
    props
  });
  const contextValue = React.useMemo(() => ({
    selected,
    indexRef,
    textRef
  }), [selected, indexRef, textRef]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_SelectItemContext.SelectItemContext.Provider, {
    value: contextValue,
    children: element
  });
}));

/**
 * An individual option in the select menu.
 * Renders a `<div>` element.
 *
 * Documentation: [Base UI Select](https://base-ui.com/react/components/select)
 */
if (process.env.NODE_ENV !== "production") InnerSelectItem.displayName = "InnerSelectItem";
const SelectItem = exports.SelectItem = /*#__PURE__*/React.forwardRef(function SelectItem(props, forwardedRef) {
  const {
    value: valueProp = null,
    label,
    ...otherProps
  } = props;
  const textRef = React.useRef(null);
  const listItem = (0, _useCompositeListItem.useCompositeListItem)({
    label,
    textRef
  });
  const {
    activeIndex,
    selectedIndex,
    setActiveIndex
  } = (0, _SelectIndexContext.useSelectIndexContext)();
  const {
    getItemProps,
    setOpen,
    setValue,
    open,
    selectionRef,
    typingRef,
    valuesRef,
    popupRef,
    registerSelectedItem,
    value,
    keyboardActiveRef,
    floatingRootContext
  } = (0, _SelectRootContext.useSelectRootContext)();
  const itemRef = React.useRef(null);
  const selectedIndexRef = (0, _useLatestRef.useLatestRef)(selectedIndex);
  const indexRef = (0, _useLatestRef.useLatestRef)(listItem.index);
  const mergedRef = (0, _useForkRef.useForkRef)(listItem.ref, forwardedRef, itemRef);
  const hasRegistered = listItem.index !== -1;
  (0, _useModernLayoutEffect.useModernLayoutEffect)(() => {
    if (!hasRegistered) {
      return undefined;
    }
    const values = valuesRef.current;
    values[listItem.index] = valueProp;
    return () => {
      delete values[listItem.index];
    };
  }, [hasRegistered, listItem.index, valueProp, valuesRef]);
  (0, _useModernLayoutEffect.useModernLayoutEffect)(() => {
    if (hasRegistered && valueProp === value) {
      registerSelectedItem(listItem.index);
    }
  }, [hasRegistered, listItem.index, registerSelectedItem, valueProp, value]);
  const highlighted = activeIndex === listItem.index;
  const selected = selectedIndex === listItem.index;
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(InnerSelectItem, {
    ref: mergedRef,
    highlighted: highlighted,
    selected: selected,
    getRootItemProps: getItemProps,
    setOpen: setOpen,
    open: open,
    selectionRef: selectionRef,
    typingRef: typingRef,
    value: valueProp,
    setValue: setValue,
    selectedIndexRef: selectedIndexRef,
    indexRef: indexRef,
    setActiveIndex: setActiveIndex,
    popupRef: popupRef,
    keyboardActiveRef: keyboardActiveRef,
    events: floatingRootContext.events,
    textRef: textRef,
    ...otherProps
  });
});
if (process.env.NODE_ENV !== "production") SelectItem.displayName = "SelectItem";