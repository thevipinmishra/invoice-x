"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useRenderElement = useRenderElement;
exports.useRenderElementLazy = useRenderElementLazy;
var React = _interopRequireWildcard(require("react"));
var _getStyleHookProps = require("./getStyleHookProps");
var _useForkRef = require("./useForkRef");
var _resolveClassName = require("./resolveClassName");
var _reactVersion = require("./reactVersion");
var _mergeProps = require("../merge-props");
var _mergeObjects = require("./mergeObjects");
var _jsxRuntime = require("react/jsx-runtime");
const EMPTY_OBJECT = {};
const IDENTITY = x => x;

/**
 * Render a Base UI element.
 */
function useRenderElement(element, componentProps, params = {}) {
  const renderProp = componentProps.render;
  const outProps = useRenderElementProps(componentProps, params);
  if (params.enabled === false) {
    return null;
  }
  const state = params.state ?? EMPTY_OBJECT;
  return evaluateRenderProp(element, renderProp, outProps, state);
}

/**
 * Returns a function that renders a Base UI element.
 *
 * @deprecated Use `useRenderElement` instead and pass `enabled = false` to its options instead.
 */
// TODO: Remove once useComponentRenderer is no longer used.
function useRenderElementLazy(element, componentProps, params = {}) {
  const renderProp = componentProps.render;
  const outProps = useRenderElementProps(componentProps, params);
  const state = params.state ?? EMPTY_OBJECT;
  return () => evaluateRenderProp(element, renderProp, outProps, state);
}

/**
 * Computes render element final props.
 */
function useRenderElementProps(componentProps, params = {}) {
  const {
    className: classNameProp,
    render: renderProp
  } = componentProps;
  const {
    propGetter = IDENTITY,
    state = EMPTY_OBJECT,
    ref,
    props,
    disableStyleHooks,
    customStyleHookMapping,
    enabled = true
  } = params;
  const className = enabled ? (0, _resolveClassName.resolveClassName)(classNameProp, state) : undefined;
  let styleHooks;
  if (disableStyleHooks !== true) {
    // SAFETY: We use typings to ensure `disableStyleHooks` is either always set or
    // always unset, so this `if` block is stable across renders.
    /* eslint-disable-next-line react-hooks/rules-of-hooks */
    styleHooks = React.useMemo(() => enabled ? (0, _getStyleHookProps.getStyleHookProps)(state, customStyleHookMapping) : EMPTY_OBJECT, [state, customStyleHookMapping, enabled]);
  }
  const outProps = enabled ? propGetter((0, _mergeObjects.mergeObjects)(styleHooks, Array.isArray(props) ? (0, _mergeProps.mergePropsN)(props) : props) ?? EMPTY_OBJECT) : EMPTY_OBJECT;

  // SAFETY: The `useForkRef` functions use a single hook to store the same value,
  // switching between them at runtime is safe. If this assertion fails, React will
  // throw at runtime anyway.
  /* eslint-disable react-hooks/rules-of-hooks */
  if (!enabled) {
    (0, _useForkRef.useForkRef)(null, null);
  } else if (Array.isArray(ref)) {
    outProps.ref = (0, _useForkRef.useForkRefN)(outProps.ref, getChildRef(renderProp), ...ref);
  } else {
    outProps.ref = (0, _useForkRef.useForkRef)(outProps.ref, getChildRef(renderProp), ref);
  }
  /* eslint-enable react-hooks/rules-of-hooks */

  if (!enabled) {
    return EMPTY_OBJECT;
  }
  if (className !== undefined) {
    outProps.className = className;
  }
  return outProps;
}
function evaluateRenderProp(element, render, props, state) {
  if (render) {
    if (typeof render === 'function') {
      return render(props, state);
    }
    const mergedProps = (0, _mergeProps.mergeProps)(props, render.props);
    mergedProps.ref = props.ref;
    return /*#__PURE__*/React.cloneElement(render, mergedProps);
  }
  if (element) {
    if (typeof element === 'string') {
      return renderTag(element, props);
    }
  }
  // Unreachable, but the typings on `useRenderElement` need to be reworked
  // to annotate it correctly.
  throw new Error('Need either element or render to be defined');
}
function renderTag(Tag, props) {
  if (Tag === 'button') {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
      type: "button",
      ...props
    });
  }
  if (Tag === 'img') {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
      alt: "",
      ...props
    });
  }
  return /*#__PURE__*/React.createElement(Tag, props);
}
function getChildRef(render) {
  if (render && typeof render !== 'function') {
    return (0, _reactVersion.isReactVersionAtLeast)(19) ? render.props.ref : render.ref;
  }
  return null;
}