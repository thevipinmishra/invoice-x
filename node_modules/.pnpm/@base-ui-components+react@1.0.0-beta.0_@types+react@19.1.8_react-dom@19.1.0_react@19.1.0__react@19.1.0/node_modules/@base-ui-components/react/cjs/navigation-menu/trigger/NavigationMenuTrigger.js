"use strict";
'use client';

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NavigationMenuTrigger = void 0;
var React = _interopRequireWildcard(require("react"));
var ReactDOM = _interopRequireWildcard(require("react-dom"));
var _react2 = require("@floating-ui/react");
var _utils = require("@floating-ui/react/utils");
var _useRenderElement = require("../../utils/useRenderElement");
var _NavigationMenuItemContext = require("../item/NavigationMenuItemContext");
var _NavigationMenuRootContext = require("../root/NavigationMenuRootContext");
var _useEventCallback = require("../../utils/useEventCallback");
var _translateOpenChangeReason = require("../../utils/translateOpenChangeReason");
var _constants = require("../../utils/constants");
var _FocusGuard = require("../../toast/viewport/FocusGuard");
var _useModernLayoutEffect = require("../../utils/useModernLayoutEffect");
var _visuallyHidden = require("../../utils/visuallyHidden");
var _CompositeItem = require("../../composite/item/CompositeItem");
var _popupStateMapping = require("../../utils/popupStateMapping");
var _isOutsideMenuEvent = require("../utils/isOutsideMenuEvent");
var _useTimeout = require("../../utils/useTimeout");
var _useAnimationFrame = require("../../utils/useAnimationFrame");
var _useLatestRef = require("../../utils/useLatestRef");
var _jsxRuntime = require("react/jsx-runtime");
const TRIGGER_IDENTIFIER = 'data-navigation-menu-trigger';

/**
 * Opens the navigation menu popup when hovered or clicked, revealing the
 * associated content.
 * Renders a `<button>` element.
 *
 * Documentation: [Base UI Navigation Menu](https://base-ui.com/react/components/navigation-menu)
 */
const NavigationMenuTrigger = exports.NavigationMenuTrigger = /*#__PURE__*/React.forwardRef(function NavigationMenuTrigger(componentProps, forwardedRef) {
  const {
    className,
    render,
    ...elementProps
  } = componentProps;
  const {
    value,
    setValue,
    mounted,
    open,
    positionerElement,
    setActivationDirection,
    setFloatingRootContext,
    popupElement,
    rootRef,
    beforeOutsideRef,
    afterOutsideRef,
    afterInsideRef,
    beforeInsideRef,
    prevTriggerElementRef,
    delay,
    closeDelay,
    orientation
  } = (0, _NavigationMenuRootContext.useNavigationMenuRootContext)();
  const itemValue = (0, _NavigationMenuItemContext.useNavigationMenuItemContext)();
  const nodeId = (0, _NavigationMenuRootContext.useNavigationMenuTreeContext)();
  const tree = (0, _react2.useFloatingTree)();
  const stickIfOpenTimeout = (0, _useTimeout.useTimeout)();
  const focusFrame = (0, _useAnimationFrame.useAnimationFrame)();
  const sizeFrame1 = (0, _useAnimationFrame.useAnimationFrame)();
  const sizeFrame2 = (0, _useAnimationFrame.useAnimationFrame)();
  const [triggerElement, setTriggerElement] = React.useState(null);
  const [stickIfOpen, setStickIfOpen] = React.useState(true);
  const [pointerType, setPointerType] = React.useState('');
  const isActiveItem = open && value === itemValue;
  const isActiveItemRef = (0, _useLatestRef.useLatestRef)(isActiveItem);
  const allowFocusRef = React.useRef(false);
  const handleValueChange = (0, _useEventCallback.useEventCallback)((currentWidth, currentHeight) => {
    if (!popupElement || !positionerElement) {
      return;
    }
    popupElement.style.removeProperty('--popup-width');
    popupElement.style.removeProperty('--popup-height');
    positionerElement.style.removeProperty('--positioner-width');
    positionerElement.style.removeProperty('--positioner-height');
    const nextWidth = popupElement.offsetWidth;
    const nextHeight = popupElement.offsetHeight;
    if (currentHeight === 0 || currentWidth === 0) {
      currentWidth = nextWidth;
      currentHeight = nextHeight;
    }
    popupElement.style.setProperty('--popup-width', `${currentWidth}px`);
    popupElement.style.setProperty('--popup-height', `${currentHeight}px`);
    positionerElement.style.setProperty('--positioner-width', `${nextWidth}px`);
    positionerElement.style.setProperty('--positioner-height', `${nextHeight}px`);
    sizeFrame1.request(() => {
      sizeFrame2.request(() => {
        popupElement.style.setProperty('--popup-width', `${nextWidth}px`);
        popupElement.style.setProperty('--popup-height', `${nextHeight}px`);
      });
    });
  });
  React.useEffect(() => {
    if (!open) {
      setPointerType('');
      stickIfOpenTimeout.clear();
      sizeFrame1.cancel();
      sizeFrame2.cancel();
    }
  }, [stickIfOpenTimeout, open, sizeFrame1, sizeFrame2]);
  (0, _useModernLayoutEffect.useModernLayoutEffect)(() => {
    if (isActiveItemRef.current && open && popupElement) {
      handleValueChange(0, 0);
    }
  }, [isActiveItemRef, open, popupElement, handleValueChange]);
  React.useEffect(() => {
    if (isActiveItem && open && popupElement && allowFocusRef.current) {
      allowFocusRef.current = false;
      focusFrame.request(() => {
        beforeOutsideRef.current?.focus();
      });
    }
    return () => {
      focusFrame.cancel();
    };
  }, [beforeOutsideRef, focusFrame, handleValueChange, isActiveItem, open, popupElement]);
  function handleOpenChange(nextOpen, event, reason) {
    const isHover = reason === 'trigger-hover';
    if (pointerType === 'touch' && isHover) {
      return;
    }
    if (!nextOpen && value !== itemValue) {
      return;
    }
    function changeState() {
      if (isHover) {
        // Only allow "patient" clicks to close the popup if it's open.
        // If they clicked within 500ms of the popup opening, keep it open.
        setStickIfOpen(true);
        stickIfOpenTimeout.clear();
        stickIfOpenTimeout.start(_constants.PATIENT_CLICK_THRESHOLD, () => {
          setStickIfOpen(false);
        });
      }
      if (nextOpen) {
        setValue(itemValue, event, reason);
      } else {
        setValue(null, event, reason);
      }
    }
    if (isHover) {
      ReactDOM.flushSync(changeState);
    } else {
      changeState();
    }
  }
  const context = (0, _react2.useFloatingRootContext)({
    open,
    onOpenChange(openValue, eventValue, reasonValue) {
      handleOpenChange(openValue, eventValue, (0, _translateOpenChangeReason.translateOpenChangeReason)(reasonValue));
    },
    elements: {
      reference: triggerElement,
      floating: positionerElement
    }
  });
  const hover = (0, _react2.useHover)(context, {
    move: false,
    handleClose: (0, _react2.safePolygon)({
      blockPointerEvents: pointerType !== 'touch'
    }),
    restMs: mounted ? 0 : delay,
    delay: {
      close: closeDelay
    }
  });
  const click = (0, _react2.useClick)(context, {
    stickIfOpen,
    toggle: isActiveItem
  });
  const dismiss = (0, _react2.useDismiss)(context, {
    enabled: isActiveItem,
    outsidePress(event) {
      // When pressing a new trigger with touch input, prevent closing the popup.
      const target = (0, _utils.getTarget)(event);
      const closestNavigationMenuTrigger = target?.closest(`[${TRIGGER_IDENTIFIER}]`);
      return closestNavigationMenuTrigger === null;
    }
  });
  (0, _useModernLayoutEffect.useModernLayoutEffect)(() => {
    if (isActiveItem) {
      setFloatingRootContext(context);
      prevTriggerElementRef.current = triggerElement;
    }
  }, [isActiveItem, context, setFloatingRootContext, prevTriggerElementRef, triggerElement]);
  const {
    getReferenceProps
  } = (0, _react2.useInteractions)([hover, click, dismiss]);
  const handleOpenEvent = (0, _useEventCallback.useEventCallback)(event => {
    if (!popupElement || !positionerElement) {
      return;
    }
    const currentWidth = popupElement.offsetWidth;
    const currentHeight = popupElement.offsetHeight;
    ReactDOM.flushSync(() => {
      const prevTriggerRect = prevTriggerElementRef.current?.getBoundingClientRect();
      if (mounted && prevTriggerRect && triggerElement) {
        const nextTriggerRect = triggerElement.getBoundingClientRect();
        const isMovingRight = nextTriggerRect.left > prevTriggerRect.left;
        const isMovingDown = nextTriggerRect.top > prevTriggerRect.top;
        if (orientation === 'horizontal' && nextTriggerRect.left !== prevTriggerRect.left) {
          setActivationDirection(isMovingRight ? 'right' : 'left');
        } else if (orientation === 'vertical' && nextTriggerRect.top !== prevTriggerRect.top) {
          setActivationDirection(isMovingDown ? 'down' : 'up');
        }
      }

      // Reset the `openEvent` to `undefined` when the active item changes so that a
      // `click` -> `hover` move to new trigger -> `hover` move back doesn't unepxpectedly
      // cause the popup to remain stuck open.
      if (event.type !== 'click') {
        context.dataRef.current.openEvent = undefined;
      }
      if (pointerType === 'touch' && event.type !== 'click') {
        return;
      }
      if (value != null) {
        setValue(itemValue, event.nativeEvent, event.type === 'mouseenter' ? 'trigger-hover' : 'trigger-press');
      }
    });
    handleValueChange(currentWidth, currentHeight);
  });
  const state = React.useMemo(() => ({
    open: isActiveItem
  }), [isActiveItem]);
  function handleSetPointerType(event) {
    setPointerType(event.pointerType);
  }
  const element = (0, _useRenderElement.useRenderElement)('button', componentProps, {
    state,
    ref: [forwardedRef, setTriggerElement],
    props: [getReferenceProps, {
      tabIndex: 0,
      onMouseEnter: handleOpenEvent,
      onClick: handleOpenEvent,
      onPointerEnter: handleSetPointerType,
      onPointerDown: handleSetPointerType,
      'aria-expanded': isActiveItem,
      'aria-controls': isActiveItem ? popupElement?.id : undefined,
      [TRIGGER_IDENTIFIER]: '',
      onMouseMove() {
        allowFocusRef.current = false;
      },
      onKeyDown(event) {
        allowFocusRef.current = true;
        const openHorizontal = orientation === 'horizontal' && event.key === 'ArrowDown';
        const openVertical = orientation === 'vertical' && event.key === 'ArrowRight';
        if (openHorizontal || openVertical) {
          setValue(itemValue, event.nativeEvent, 'list-navigation');
          (0, _utils.stopEvent)(event);
        }
      },
      onBlur(event) {
        if (event.relatedTarget && (0, _isOutsideMenuEvent.isOutsideMenuEvent)({
          currentTarget: event.currentTarget,
          relatedTarget: event.relatedTarget
        }, {
          popupElement,
          rootRef,
          tree,
          nodeId
        })) {
          setValue(null, event.nativeEvent, 'focus-out');
        }
      }
    }, elementProps],
    customStyleHookMapping: _popupStateMapping.pressableTriggerOpenStateMapping
  });
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_CompositeItem.CompositeItem, {
      render: element
    }), isActiveItem && /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_FocusGuard.FocusGuard, {
        ref: beforeOutsideRef,
        onFocus: event => {
          if (positionerElement && (0, _utils.isOutsideEvent)(event, positionerElement)) {
            beforeInsideRef.current?.focus();
          } else {
            const prevTabbable = (0, _utils.getPreviousTabbable)(triggerElement);
            prevTabbable?.focus();
          }
        }
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        "aria-owns": popupElement?.id,
        style: _visuallyHidden.visuallyHidden
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_FocusGuard.FocusGuard, {
        ref: afterOutsideRef,
        onFocus: event => {
          if (positionerElement && (0, _utils.isOutsideEvent)(event, positionerElement)) {
            afterInsideRef.current?.focus();
          } else {
            const nextTabbable = (0, _utils.getNextTabbable)(triggerElement);
            nextTabbable?.focus();
            if (!(0, _utils.contains)(rootRef.current, nextTabbable)) {
              setValue(null, event.nativeEvent, 'focus-out');
            }
          }
        }
      })]
    })]
  });
});
if (process.env.NODE_ENV !== "production") NavigationMenuTrigger.displayName = "NavigationMenuTrigger";