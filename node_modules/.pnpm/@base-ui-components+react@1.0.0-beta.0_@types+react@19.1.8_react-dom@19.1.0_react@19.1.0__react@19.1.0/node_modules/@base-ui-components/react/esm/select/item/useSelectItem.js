import * as React from 'react';
import { useButton } from "../../use-button/index.js";
import { mergeProps } from "../../merge-props/index.js";
import { useTimeout } from "../../utils/useTimeout.js";
import { useEventCallback } from "../../utils/useEventCallback.js";
import { useForkRef } from "../../utils/useForkRef.js";
import { useModernLayoutEffect } from "../../utils/index.js";
import { addHighlight, hasHighlight, removeHighlight } from "../../utils/highlighted.js";
import { isMouseWithinBounds } from "../../utils/isMouseWithinBounds.js";
import { AnimationFrame } from "../../utils/useAnimationFrame.js";
export function useSelectItem(params) {
  const {
    open,
    disabled = false,
    highlighted,
    selected,
    ref: externalRef,
    setOpen,
    typingRef,
    handleSelect,
    selectionRef,
    indexRef,
    setActiveIndex,
    selectedIndexRef,
    popupRef,
    keyboardActiveRef,
    events,
    elementProps,
    rootProps
  } = params;
  const ref = React.useRef(null);
  const lastKeyRef = React.useRef(null);
  const pointerTypeRef = React.useRef('mouse');
  const didPointerDownRef = React.useRef(false);
  const prevPopupHeightRef = React.useRef(0);
  const allowFocusSyncRef = React.useRef(true);
  const cursorMovementTimeout = useTimeout();
  const mergedRef = useForkRef(externalRef, ref);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    buttonRef: mergedRef
  });
  const commitSelection = useEventCallback(event => {
    handleSelect(event);
    setOpen(false, event, 'item-press');
  });
  const handlePopupLeave = useEventCallback(() => {
    if (cursorMovementTimeout.isStarted()) {
      cursorMovementTimeout.clear();
      removeHighlight(ref);
    }
  });
  React.useEffect(() => {
    return handlePopupLeave;
  }, [handlePopupLeave]);
  useModernLayoutEffect(() => {
    if (!open) {
      return;
    }
    if (highlighted) {
      addHighlight(ref);
    } else {
      removeHighlight(ref);
    }
  }, [open, highlighted]);
  React.useEffect(() => {
    function handleItemHover(item) {
      if (ref.current && item !== ref.current) {
        removeHighlight(ref);
      }
    }
    events.on('itemhover', handleItemHover);
    return () => {
      events.off('itemhover', handleItemHover);
    };
  }, [events, setActiveIndex, indexRef]);
  const props = mergeProps(rootProps, {
    'aria-disabled': disabled || undefined,
    tabIndex: highlighted ? 0 : -1,
    onFocus() {
      if (allowFocusSyncRef.current && keyboardActiveRef.current && cursorMovementTimeout.isStarted() === false) {
        setActiveIndex(indexRef.current);
      }
    },
    onMouseEnter() {
      if (!keyboardActiveRef.current && selectedIndexRef.current === null) {
        addHighlight(ref);
        events.emit('itemhover', ref.current);
      }
    },
    onMouseMove() {
      if (keyboardActiveRef.current) {
        setActiveIndex(indexRef.current);
      } else {
        addHighlight(ref);
        events.emit('itemhover', ref.current);
      }
      if (popupRef.current) {
        prevPopupHeightRef.current = popupRef.current.offsetHeight;
      }
      events.off('popupleave', handlePopupLeave);
      events.on('popupleave', handlePopupLeave);
      // When this fires, the cursor has stopped moving.
      cursorMovementTimeout.start(50, () => {
        setActiveIndex(indexRef.current);
      });
    },
    onMouseLeave(event) {
      const popup = popupRef.current;
      if (!popup || !open || keyboardActiveRef.current) {
        return;
      }
      if (isMouseWithinBounds(event)) {
        return;
      }
      removeHighlight(ref);
      events.off('popupleave', handlePopupLeave);
      const wasCursorStationary = cursorMovementTimeout.isStarted() === false;
      if (!wasCursorStationary) {
        cursorMovementTimeout.clear();
      }

      // With `alignItemWithTrigger=true`, avoid re-rendering the root due to `onMouseLeave`
      // firing and causing a performance issue when expanding the popup.
      if (popup.offsetHeight === prevPopupHeightRef.current) {
        // Prevent `onFocus` from causing the highlight to be stuck when quickly moving
        // the mouse out of the popup.
        allowFocusSyncRef.current = false;
        if (keyboardActiveRef.current || wasCursorStationary) {
          setActiveIndex(null);
        }
        AnimationFrame.request(() => {
          cursorMovementTimeout.clear();
          allowFocusSyncRef.current = true;
        });
      }
    },
    onTouchStart() {
      selectionRef.current = {
        allowSelectedMouseUp: false,
        allowUnselectedMouseUp: false,
        allowSelect: true
      };
    },
    onKeyDown(event) {
      selectionRef.current.allowSelect = true;
      lastKeyRef.current = event.key;
      setActiveIndex(indexRef.current);
    },
    onClick(event) {
      didPointerDownRef.current = false;

      // Prevent double commit on {Enter}
      if (event.type === 'keydown' && lastKeyRef.current === null) {
        return;
      }
      if (disabled || lastKeyRef.current === ' ' && typingRef.current || pointerTypeRef.current !== 'touch' && !hasHighlight(ref)) {
        return;
      }
      if (selectionRef.current.allowSelect) {
        lastKeyRef.current = null;
        commitSelection(event.nativeEvent);
      }
    },
    onPointerEnter(event) {
      pointerTypeRef.current = event.pointerType;
    },
    onPointerDown(event) {
      pointerTypeRef.current = event.pointerType;
      didPointerDownRef.current = true;
    },
    onMouseUp(event) {
      if (disabled) {
        return;
      }
      if (didPointerDownRef.current) {
        didPointerDownRef.current = false;
        return;
      }
      const disallowSelectedMouseUp = !selectionRef.current.allowSelectedMouseUp && selected;
      const disallowUnselectedMouseUp = !selectionRef.current.allowUnselectedMouseUp && !selected;
      if (disallowSelectedMouseUp || disallowUnselectedMouseUp || pointerTypeRef.current !== 'touch' && !hasHighlight(ref)) {
        return;
      }
      if (selectionRef.current.allowSelect || !selected) {
        commitSelection(event.nativeEvent);
      }
      selectionRef.current.allowSelect = true;
    }
  }, elementProps, getButtonProps);
  return {
    rootRef: buttonRef,
    props
  };
}